[
  {
    "question": "What is the difference between HashMap and ConcurrentHashMap?",
    "idealAnswer": "HashMap is not thread-safe and allows one null key and multiple null values. ConcurrentHashMap is thread-safe, does not allow null keys or values, and achieves concurrency through lock striping (Java 7) or CAS + synchronized blocks on individual buckets (Java 8+). HashMap offers better single-threaded performance, while ConcurrentHashMap is designed for high-concurrency scenarios without locking the entire map.",
    "requiredConcepts": [
      "thread safety",
      "synchronization",
      "locking",
      "performance"
    ],
    "advancedConcepts": [
      "CAS (Compare-And-Swap)",
      "lock striping",
      "segment removal in Java 8",
      "volatile reads"
    ],
    "difficulty": "mid",
    "experience": "3-5"
  },
  {
    "question": "Explain the internal working of HashMap in Java.",
    "idealAnswer": "HashMap uses an array of buckets (Node<K,V>[]) where each bucket is a linked list (or a red-black tree when the list exceeds 8 elements). The key's hashCode() is used to compute the bucket index. When two keys hash to the same bucket, they are stored as a linked list (chaining). The map resizes (doubles capacity) when the load factor threshold (default 0.75) is exceeded, rehashing all entries.",
    "requiredConcepts": [
      "hashing",
      "buckets",
      "collision resolution",
      "load factor",
      "rehashing"
    ],
    "advancedConcepts": [
      "treeification threshold (8)",
      "red-black tree conversion",
      "hash spreading (h ^ h >>> 16)",
      "capacity always power of 2"
    ],
    "difficulty": "mid",
    "experience": "3-5"
  },
  {
    "question": "What is the difference between checked and unchecked exceptions in Java?",
    "idealAnswer": "Checked exceptions extend Exception (excluding RuntimeException) and must be declared in the method signature with 'throws' or caught in a try-catch block. They represent recoverable conditions (e.g., IOException, SQLException). Unchecked exceptions extend RuntimeException and do not need to be declared or caught — they typically represent programming errors (e.g., NullPointerException, IllegalArgumentException).",
    "requiredConcepts": [
      "exception hierarchy",
      "checked vs unchecked",
      "throws declaration",
      "try-catch"
    ],
    "advancedConcepts": [
      "exception chaining",
      "custom exception design",
      "checked exceptions and lambdas incompatibility",
      "anti-patterns of swallowing exceptions"
    ],
    "difficulty": "junior",
    "experience": "0-2"
  },
  {
    "question": "What is the difference between @Component, @Service, @Repository, and @Controller in Spring?",
    "idealAnswer": "All four are specializations of @Component and trigger Spring bean registration via classpath scanning. @Service marks business logic layer components. @Repository marks data access layer components and additionally enables Spring's persistence exception translation (converting DB-specific exceptions to Spring's DataAccessException). @Controller marks MVC controllers and integrates with Spring MVC's dispatcher. Functionally they're largely interchangeable, but semantically and tooling-wise they carry important meaning.",
    "requiredConcepts": [
      "Spring stereotype annotations",
      "bean registration",
      "component scanning",
      "layered architecture"
    ],
    "advancedConcepts": [
      "exception translation proxy for @Repository",
      "AOP proxying differences",
      "@RestController vs @Controller",
      "meta-annotations"
    ],
    "difficulty": "junior",
    "experience": "1-3"
  },
  {
    "question": "Explain the Spring Bean lifecycle.",
    "idealAnswer": "Spring bean lifecycle: 1) Instantiation — Spring creates the bean instance. 2) Dependency injection — properties and constructor args are injected. 3) Aware interfaces — BeanNameAware, ApplicationContextAware callbacks are invoked. 4) BeanPostProcessor#postProcessBeforeInitialization. 5) @PostConstruct / InitializingBean#afterPropertiesSet / custom init-method. 6) BeanPostProcessor#postProcessAfterInitialization. 7) Bean is ready. 8) On context close: @PreDestroy / DisposableBean#destroy / custom destroy-method.",
    "requiredConcepts": [
      "instantiation",
      "dependency injection",
      "initialization callbacks",
      "destruction callbacks"
    ],
    "advancedConcepts": [
      "BeanPostProcessor",
      "BeanFactoryPostProcessor",
      "SmartInitializingSingleton",
      "prototype scope and destruction",
      "circular dependency handling"
    ],
    "difficulty": "mid",
    "experience": "3-5"
  },
  {
    "question": "What is the difference between JPA's FetchType.LAZY and FetchType.EAGER?",
    "idealAnswer": "EAGER loading fetches the associated entity/collection immediately when the parent entity is loaded, using a JOIN or additional SELECT. LAZY loading defers fetching until the association is first accessed. LAZY is generally preferred for collections to avoid loading large datasets unnecessarily. However, LAZY can cause LazyInitializationException if the Hibernate session is closed before the proxy is initialized.",
    "requiredConcepts": [
      "lazy vs eager loading",
      "N+1 problem",
      "Hibernate proxy",
      "session scope"
    ],
    "advancedConcepts": [
      "LazyInitializationException causes and fixes",
      "fetch join in JPQL",
      "EntityGraph for dynamic fetching",
      "Hibernate batch fetching"
    ],
    "difficulty": "mid",
    "experience": "3-5"
  },
  {
    "question": "What is the N+1 query problem and how do you solve it?",
    "idealAnswer": "The N+1 problem occurs when loading N parent entities triggers N additional queries to fetch their associations. For example, loading 100 Orders and accessing order.getItems() for each triggers 100 extra SELECT statements. Solutions include: using JOIN FETCH in JPQL, defining @EntityGraph to eagerly load specific associations, enabling Hibernate batch fetching (@BatchSize), or using DTO projections.",
    "requiredConcepts": [
      "lazy loading",
      "association fetching",
      "query optimization",
      "JPA/Hibernate"
    ],
    "advancedConcepts": [
      "JOIN FETCH vs EntityGraph trade-offs",
      "Hibernate statistics to detect N+1",
      "subselect fetching",
      "DTO projections with JPQL constructor expressions"
    ],
    "difficulty": "mid",
    "experience": "3-5"
  },
  {
    "question": "Explain how Spring's @Transactional works internally.",
    "idealAnswer": "@Transactional is implemented via AOP proxying. When a bean method annotated with @Transactional is called, Spring's proxy intercepts the call, begins a transaction via the PlatformTransactionManager, executes the method, and commits or rolls back based on the outcome. By default, rollback occurs only for unchecked exceptions. The annotation has no effect when calling a @Transactional method from within the same class (self-invocation) because the call bypasses the proxy.",
    "requiredConcepts": [
      "AOP proxy",
      "transaction management",
      "commit/rollback",
      "propagation"
    ],
    "advancedConcepts": [
      "self-invocation problem",
      "transaction propagation levels (REQUIRES_NEW, NESTED)",
      "isolation levels",
      "readOnly optimization",
      "TransactionSynchronizationManager"
    ],
    "difficulty": "senior",
    "experience": "5+"
  },
  {
    "question": "What are the SOLID principles? Give a Java example for each.",
    "idealAnswer": "S — Single Responsibility: a class should have one reason to change (e.g., separate UserService from EmailService). O — Open/Closed: open for extension, closed for modification (e.g., use strategy pattern instead of if-else chains). L — Liskov Substitution: subclasses must be substitutable for their base class without breaking behavior. I — Interface Segregation: prefer many small interfaces over one fat interface. D — Dependency Inversion: depend on abstractions, not concretions (inject interfaces, not implementations).",
    "requiredConcepts": [
      "SRP",
      "OCP",
      "LSP",
      "ISP",
      "DIP",
      "design principles"
    ],
    "advancedConcepts": [
      "SOLID violations as code smells",
      "how Spring DI enforces DIP",
      "LSP violations with exceptions",
      "ISP and microservice API design"
    ],
    "difficulty": "mid",
    "experience": "3-5"
  },
  {
    "question": "What is the difference between optimistic and pessimistic locking in JPA?",
    "idealAnswer": "Optimistic locking assumes conflicts are rare. It uses a @Version field (integer or timestamp) — before updating, JPA checks the version hasn't changed since the entity was read. If it has, it throws OptimisticLockException. No database lock is held during the read. Pessimistic locking acquires a database-level lock (SELECT FOR UPDATE) immediately on read, preventing other transactions from modifying the row until the lock is released.",
    "requiredConcepts": [
      "concurrency control",
      "version field",
      "database locking",
      "transaction isolation"
    ],
    "advancedConcepts": [
      "LockModeType.PESSIMISTIC_READ vs WRITE",
      "optimistic lock retry strategies",
      "deadlock risk with pessimistic locking",
      "MVCC in databases"
    ],
    "difficulty": "senior",
    "experience": "5+"
  },
  {
    "question": "How does the Java memory model (JMM) work? What guarantees does 'volatile' provide?",
    "idealAnswer": "The JMM defines how threads interact through memory. Each thread may cache variables in its working memory (CPU cache/registers). Without synchronization, writes by one thread may not be visible to another. The 'volatile' keyword guarantees visibility: a write to a volatile variable is immediately flushed to main memory, and a read always fetches from main memory. It also prevents instruction reordering around the volatile access. However, volatile does not guarantee atomicity for compound operations like i++.",
    "requiredConcepts": [
      "visibility",
      "happens-before",
      "volatile",
      "memory caching"
    ],
    "advancedConcepts": [
      "happens-before relationship",
      "double-checked locking with volatile",
      "volatile vs AtomicInteger",
      "CPU cache coherence protocols"
    ],
    "difficulty": "senior",
    "experience": "5+"
  },
  {
    "question": "What are the main garbage collection algorithms in the JVM, and how do you choose between them?",
    "idealAnswer": "Serial GC: single-threaded, for small heaps. Parallel GC: multi-threaded throughput-focused, suitable for batch workloads. G1 GC (default since Java 9): splits heap into regions, aims for predictable pause times, good balance for most applications. ZGC and Shenandoah: ultra-low latency collectors with sub-millisecond pauses, suitable for large heaps and latency-sensitive apps. Choice depends on: heap size, latency requirements, and throughput needs.",
    "requiredConcepts": [
      "GC algorithms",
      "heap regions",
      "pause times",
      "throughput vs latency"
    ],
    "advancedConcepts": [
      "generational hypothesis",
      "GC tuning flags (-Xmx, -XX:MaxGCPauseMillis)",
      "GC log analysis",
      "ZGC concurrent phases",
      "memory leak detection"
    ],
    "difficulty": "senior",
    "experience": "5+"
  },
  {
    "question": "What is Spring Security's filter chain and how does authentication work?",
    "idealAnswer": "Spring Security is implemented as a chain of servlet filters (SecurityFilterChain). Key filters include: UsernamePasswordAuthenticationFilter (processes login form), BasicAuthenticationFilter, BearerTokenAuthenticationFilter (JWT), and ExceptionTranslationFilter. When a request arrives, filters are applied in order. The authentication filter extracts credentials, creates an Authentication object, and passes it to AuthenticationManager (typically ProviderManager), which delegates to AuthenticationProviders. On success, the Authentication is stored in SecurityContextHolder.",
    "requiredConcepts": [
      "filter chain",
      "AuthenticationManager",
      "SecurityContext",
      "AuthenticationProvider"
    ],
    "advancedConcepts": [
      "JWT stateless authentication flow",
      "OAuth2 resource server configuration",
      "method security (@PreAuthorize)",
      "SecurityContextHolder strategy (ThreadLocal)",
      "CSRF token handling"
    ],
    "difficulty": "senior",
    "experience": "5+"
  },
  {
    "question": "Explain the difference between REST and gRPC. When would you choose one over the other?",
    "idealAnswer": "REST uses HTTP/1.1 with JSON (typically), is human-readable, widely supported, and stateless. gRPC uses HTTP/2 with Protocol Buffers (binary), is strongly typed, supports streaming (unary, server-streaming, client-streaming, bidirectional), and has lower latency and higher throughput. Choose REST for public APIs, browser clients, or when interoperability matters. Choose gRPC for internal microservice communication requiring high performance, streaming, or strong contracts.",
    "requiredConcepts": [
      "HTTP/1.1 vs HTTP/2",
      "serialization formats",
      "API contract",
      "streaming"
    ],
    "advancedConcepts": [
      "Protocol Buffers schema evolution",
      "gRPC interceptors vs Spring filters",
      "gRPC-web for browser support",
      "REST HATEOAS",
      "bidirectional streaming use cases"
    ],
    "difficulty": "mid",
    "experience": "3-5"
  },
  {
    "question": "What is eventual consistency and how does it apply to microservices?",
    "idealAnswer": "Eventual consistency means that, given no new updates, all replicas of data will converge to the same value over time — but reads may return stale data in the interim. In microservices, each service owns its database, and synchronizing state across services happens asynchronously (e.g., via events). Patterns like the Saga pattern, CQRS, and event sourcing are used to manage consistency without distributed transactions.",
    "requiredConcepts": [
      "consistency models",
      "distributed systems",
      "asynchronous communication",
      "CAP theorem"
    ],
    "advancedConcepts": [
      "Saga pattern (choreography vs orchestration)",
      "outbox pattern",
      "idempotent consumers",
      "compensating transactions",
      "event sourcing"
    ],
    "difficulty": "senior",
    "experience": "5+"
  },
  {
    "question": "What is the difference between ExecutorService, ForkJoinPool, and virtual threads (Project Loom)?",
    "idealAnswer": "ExecutorService manages a pool of OS threads for executing tasks; thread count is fixed or bounded. ForkJoinPool is optimized for recursive divide-and-conquer tasks using work-stealing — idle threads steal tasks from busy threads' queues. Virtual threads (Java 21+, Project Loom) are lightweight JVM-managed threads that are cheap to create (millions possible), blocking operations unmount the carrier thread rather than blocking it, making them ideal for high-concurrency I/O-bound workloads without reactive programming complexity.",
    "requiredConcepts": [
      "thread pools",
      "concurrency",
      "task execution",
      "blocking vs non-blocking"
    ],
    "advancedConcepts": [
      "work-stealing algorithm",
      "virtual thread pinning",
      "structured concurrency (JEP 428)",
      "carrier thread vs virtual thread",
      "reactive vs Loom trade-offs"
    ],
    "difficulty": "senior",
    "experience": "5+"
  },
  {
    "question": "How does database indexing work and when should you avoid indexes?",
    "idealAnswer": "An index is a data structure (commonly B-tree) that allows the database to find rows without a full table scan. Indexes speed up SELECT queries on indexed columns but add overhead to INSERT/UPDATE/DELETE because the index must also be updated. Avoid indexes on: columns with very low cardinality (e.g., boolean flags), small tables where full scans are faster, columns rarely used in WHERE/JOIN/ORDER BY clauses, and write-heavy tables where index maintenance cost outweighs read benefits.",
    "requiredConcepts": [
      "B-tree index",
      "query optimization",
      "cardinality",
      "read vs write trade-offs"
    ],
    "advancedConcepts": [
      "composite index column order",
      "covering indexes",
      "index selectivity",
      "partial indexes",
      "EXPLAIN ANALYZE output interpretation"
    ],
    "difficulty": "mid",
    "experience": "3-5"
  },
  {
    "question": "What are the differences between monolithic and microservices architectures?",
    "idealAnswer": "A monolith is a single deployable unit where all components share the same process and database. Advantages: simpler development, testing, and deployment initially; easier transactions and data consistency. Microservices decompose the application into independently deployable services, each with its own database. Advantages: independent scaling, technology flexibility, fault isolation, team autonomy. Drawbacks of microservices: increased operational complexity, distributed system challenges (network latency, data consistency, tracing).",
    "requiredConcepts": [
      "deployment units",
      "service boundaries",
      "scalability",
      "data ownership"
    ],
    "advancedConcepts": [
      "strangler fig migration pattern",
      "service mesh (Istio)",
      "distributed tracing (OpenTelemetry)",
      "API gateway patterns",
      "domain-driven design for service decomposition"
    ],
    "difficulty": "mid",
    "experience": "3-5"
  },
  {
    "question": "Explain Java's CompletableFuture and its advantages over Future.",
    "idealAnswer": "Future represents an async computation result but blocks on get() and offers no composition. CompletableFuture extends Future and adds: non-blocking callbacks (thenApply, thenAccept, thenRun), composition (thenCompose, thenCombine), error handling (exceptionally, handle), and the ability to complete manually. It enables building non-blocking async pipelines without blocking threads. Multiple CompletableFutures can be combined with allOf/anyOf.",
    "requiredConcepts": [
      "asynchronous programming",
      "non-blocking",
      "callback chaining",
      "Future limitations"
    ],
    "advancedConcepts": [
      "custom executor for CompletableFuture stages",
      "exception propagation in pipelines",
      "thenCompose vs thenApply distinction",
      "CompletableFuture vs reactive streams backpressure"
    ],
    "difficulty": "mid",
    "experience": "3-5"
  },
  {
    "question": "What is the difference between @Bean and @Component in Spring?",
    "idealAnswer": "@Component (and its specializations) is a class-level annotation that marks a class for auto-detection via classpath scanning. @Bean is a method-level annotation inside a @Configuration class, used to explicitly declare and configure a bean, typically for third-party classes you can't annotate directly. @Bean gives full programmatic control over the instantiation logic, while @Component relies on Spring's auto-wiring.",
    "requiredConcepts": [
      "bean declaration",
      "component scanning",
      "@Configuration",
      "Spring IoC"
    ],
    "advancedConcepts": [
      "CGLIB proxying of @Configuration classes",
      "@Bean in @Component vs @Configuration (lite mode)",
      "bean overriding",
      "conditional beans (@ConditionalOnMissingBean)"
    ],
    "difficulty": "junior",
    "experience": "1-3"
  },
  {
    "question": "What is connection pooling and why is it important? How does HikariCP work?",
    "idealAnswer": "Creating a new database connection is expensive (TCP handshake, authentication, session setup). Connection pooling maintains a pool of pre-established connections that are reused across requests. HikariCP is the default Spring Boot connection pool — it maintains a fixed pool of connections, borrows a connection to a thread for the duration of a DB operation, then returns it to the pool. It uses a lock-free design with ConcurrentBag for high throughput. Key config: maximumPoolSize, minimumIdle, connectionTimeout.",
    "requiredConcepts": [
      "connection reuse",
      "pool sizing",
      "connection lifecycle",
      "latency reduction"
    ],
    "advancedConcepts": [
      "HikariCP ConcurrentBag internals",
      "pool exhaustion and connectionTimeout",
      "keepAliveTime vs idleTimeout",
      "connection validation (connectionTestQuery)",
      "pool sizing formula (Little's Law)"
    ],
    "difficulty": "mid",
    "experience": "3-5"
  },
  {
    "question": "How does Kafka ensure message ordering and exactly-once delivery?",
    "idealAnswer": "Kafka guarantees ordering within a partition — messages with the same partition key go to the same partition, preserving order per key. Across partitions, ordering is not guaranteed. For exactly-once semantics (EOS): producers use idempotent producers (enable.idempotence=true) to deduplicate retried messages, and transactional APIs to atomically write to multiple partitions. Consumers use isolation.level=read_committed to only read committed transactional messages.",
    "requiredConcepts": [
      "partition ordering",
      "at-least-once delivery",
      "idempotent producer",
      "consumer groups"
    ],
    "advancedConcepts": [
      "Kafka transactions API",
      "producer epoch and sequence numbers",
      "Kafka Streams EOS",
      "outbox pattern as alternative",
      "offset management strategies"
    ],
    "difficulty": "senior",
    "experience": "5+"
  },
  {
    "question": "What are common caching strategies and how would you implement caching in a Spring Boot application?",
    "idealAnswer": "Common strategies: Cache-aside (app checks cache, loads from DB on miss), Write-through (write to cache and DB simultaneously), Write-behind (write to cache, async flush to DB), Read-through (cache loads from DB on miss automatically). In Spring Boot, use @EnableCaching with @Cacheable, @CacheEvict, @CachePut annotations. Configure a CacheManager backed by Caffeine (in-memory) or Redis (distributed). Consider TTL, cache invalidation, and cache stampede protection.",
    "requiredConcepts": [
      "cache-aside",
      "TTL",
      "cache invalidation",
      "@Cacheable"
    ],
    "advancedConcepts": [
      "cache stampede / thundering herd",
      "distributed cache consistency",
      "Caffeine vs Redis trade-offs",
      "conditional caching (@Cacheable condition)",
      "cache warming strategies"
    ],
    "difficulty": "mid",
    "experience": "3-5"
  },
  {
    "question": "Explain the difference between INNER JOIN, LEFT JOIN, and how to optimize JOIN queries.",
    "idealAnswer": "INNER JOIN returns only rows where there's a match in both tables. LEFT JOIN returns all rows from the left table and matched rows from the right; unmatched right-side columns are NULL. To optimize JOINs: ensure JOIN columns are indexed, avoid joining on non-indexed or computed columns, reduce the result set before joining using WHERE clauses, use EXPLAIN to check query plans, avoid SELECT * across JOINs, and consider denormalization for read-heavy workloads.",
    "requiredConcepts": [
      "JOIN types",
      "NULL handling",
      "indexing JOIN columns",
      "query execution plan"
    ],
    "advancedConcepts": [
      "hash join vs nested loop join vs sort-merge join",
      "join ordering by optimizer",
      "statistics and query planner",
      "covering index for JOIN columns",
      "lateral joins"
    ],
    "difficulty": "mid",
    "experience": "3-5"
  },
  {
    "question": "What is circuit breaker pattern and how is it implemented with Resilience4j?",
    "idealAnswer": "The circuit breaker pattern prevents cascading failures in distributed systems. It wraps remote calls and tracks failure rates. States: CLOSED (normal, calls pass through), OPEN (failures exceeded threshold, calls fail fast without hitting the remote service), HALF_OPEN (after a wait duration, test calls are allowed to check if the service recovered). With Resilience4j, use @CircuitBreaker annotation or CircuitBreakerRegistry, configuring failureRateThreshold, waitDurationInOpenState, and permittedNumberOfCallsInHalfOpenState.",
    "requiredConcepts": [
      "circuit breaker states",
      "fail fast",
      "fault tolerance",
      "cascading failures"
    ],
    "advancedConcepts": [
      "sliding window (count-based vs time-based)",
      "bulkhead pattern combination",
      "fallback methods",
      "Resilience4j metrics with Micrometer",
      "retry vs circuit breaker interaction"
    ],
    "difficulty": "senior",
    "experience": "5+"
  },
  {
    "question": "What is the difference between @PathVariable, @RequestParam, and @RequestBody in Spring MVC?",
    "idealAnswer": "@PathVariable extracts values from the URI path (e.g., /users/{id}). @RequestParam extracts query string parameters (e.g., /users?page=1). @RequestBody deserializes the HTTP request body (typically JSON) into a Java object using HttpMessageConverters (e.g., Jackson). @PathVariable and @RequestParam are used for simple scalar values, while @RequestBody is used for complex payloads in POST/PUT requests.",
    "requiredConcepts": [
      "HTTP request structure",
      "URI templates",
      "query parameters",
      "request body deserialization"
    ],
    "advancedConcepts": [
      "content negotiation",
      "HttpMessageConverter customization",
      "validation with @Valid on @RequestBody",
      "@RequestPart for multipart",
      "BindingResult for validation errors"
    ],
    "difficulty": "junior",
    "experience": "1-3"
  },
  {
    "question": "How would you design a rate limiter for a REST API?",
    "idealAnswer": "Common algorithms: Token Bucket (tokens added at fixed rate, request consumes a token — allows bursts), Leaky Bucket (requests processed at fixed rate — smooths bursts), Fixed Window Counter (count requests per time window), Sliding Window Log (track timestamps of requests in a rolling window). In Java/Spring: use Resilience4j RateLimiter, Bucket4j with Redis for distributed rate limiting, or API Gateway-level rate limiting. Store counters in Redis for distributed environments with atomic INCR + EXPIRE.",
    "requiredConcepts": [
      "rate limiting algorithms",
      "token bucket",
      "fixed window",
      "distributed state"
    ],
    "advancedConcepts": [
      "sliding window log vs sliding window counter",
      "Redis Lua scripts for atomic operations",
      "rate limit headers (X-RateLimit-*)",
      "rate limiting by IP vs user vs API key",
      "Resilience4j RateLimiter internals"
    ],
    "difficulty": "senior",
    "experience": "5+"
  },
  {
    "question": "What are Java Streams and how do they differ from collections?",
    "idealAnswer": "Java Streams (java.util.stream) represent a pipeline of operations on a sequence of elements. Unlike collections, streams: are not data structures (they don't store elements), are lazily evaluated (intermediate operations only run when a terminal operation is invoked), are consumable (can only be traversed once), and support parallelism via parallelStream(). Collections are in-memory data structures. Streams enable a declarative, functional style for data transformation and aggregation.",
    "requiredConcepts": [
      "lazy evaluation",
      "terminal vs intermediate operations",
      "functional programming",
      "pipeline"
    ],
    "advancedConcepts": [
      "spliterator for custom streams",
      "parallel stream pitfalls (shared mutable state)",
      "Collectors.teeing (Java 12)",
      "primitive streams (IntStream) for performance",
      "stream short-circuiting"
    ],
    "difficulty": "junior",
    "experience": "1-3"
  },
  {
    "question": "Explain the difference between Spring's ApplicationContext and BeanFactory.",
    "idealAnswer": "BeanFactory is the basic IoC container providing bean instantiation and dependency injection. ApplicationContext extends BeanFactory and adds: internationalization (MessageSource), event publication (ApplicationEventPublisher), AOP integration, environment abstraction, and eager initialization of singleton beans at startup. In practice, ApplicationContext (e.g., AnnotationConfigApplicationContext, SpringApplication) is always used; BeanFactory is rarely used directly.",
    "requiredConcepts": [
      "IoC container",
      "bean lifecycle",
      "eager vs lazy initialization",
      "Spring context hierarchy"
    ],
    "advancedConcepts": [
      "ApplicationContext event system",
      "parent/child context hierarchy (Spring MVC)",
      "BeanDefinitionRegistry",
      "AnnotationConfigApplicationContext vs ClassPathXmlApplicationContext",
      "context refresh lifecycle"
    ],
    "difficulty": "mid",
    "experience": "3-5"
  },
  {
    "question": "How does JWT-based authentication work and what are its security considerations?",
    "idealAnswer": "JWT (JSON Web Token) consists of three base64-encoded parts: Header (algorithm), Payload (claims like sub, exp, roles), and Signature. The server signs the token with a secret (HMAC) or private key (RSA/ECDSA). The client sends the JWT in the Authorization: Bearer header. The server verifies the signature and reads claims without a database lookup — making JWT stateless. Security considerations: use short expiry + refresh tokens, store securely (httpOnly cookies preferred over localStorage), validate all claims (exp, iss, aud), and use asymmetric keys for multi-service architectures.",
    "requiredConcepts": [
      "JWT structure",
      "stateless authentication",
      "signature verification",
      "token expiry"
    ],
    "advancedConcepts": [
      "JWT vs opaque tokens",
      "refresh token rotation",
      "JWK endpoint for public key distribution",
      "token revocation challenges",
      "alg:none attack and algorithm confusion attacks"
    ],
    "difficulty": "mid",
    "experience": "3-5"
  }
]
